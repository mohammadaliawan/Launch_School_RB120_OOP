# Study Guide

You should be able to explain these concepts with clarity.

## Specific Topics of Interest

- Classes and objects (15-Jan)  (18-Jan)
- Use attr_* to create setter and getter methods (15-Jan)  (18-Jan)
- How to call setters and getters (15-Jan)  (18-Jan)
- Instance methods vs. class methods (15-Jan)  (18-Jan)
- Method Access Control (15-Jan)  (18-Jan)
- Referencing and setting instance variables vs. using getters and setters (15-Jan)  (18-Jan)
- Class inheritance, encapsulation, and polymorphism (15-Jan)  (18-Jan)
  Calling methods with self (15-Jan)  (18-Jan)
  More about self (15-Jan)  (18-Jan)
- self (15-Jan)  (18-Jan)


- Instance variables, class variables, and constants, including the scope of each type and how inheritance can affect that scope  (16-Jan) (17-Jan)
- Modules  (16-Jan)(17-Jan)
- Method lookup path  (16-Jan)(17-Jan)
- Fake operators and equality  (16-Jan)  (17-Jan)

- Reading OO code (Debugging)  (17-Jan)
- Working with collaborator objects  (17-Jan)
- DOing a spike  (17-Jan)

15-Jan

- Classes and objects (15-Jan)  (18-Jan)
- Use attr_* to create setter and getter methods (15-Jan)  (18-Jan)
- How to call setters and getters (15-Jan)  (18-Jan)
- Instance methods vs. class methods (15-Jan)  (18-Jan)
- Method Access Control (15-Jan)  (18-Jan)
- Referencing and setting instance variables vs. using getters and setters (15-Jan)  (18-Jan)
- Class inheritance, encapsulation, and polymorphism (15-Jan)  (18-Jan)
  Calling methods with self (15-Jan)  (18-Jan)
  More about self (15-Jan)  (18-Jan)
- self (15-Jan)  (18-Jan)

16-Jan

- Instance variables, class variables, and constants, including the scope of each type and how inheritance can affect that scope  (16-Jan) (17-Jan)
- Modules  (16-Jan)(17-Jan)
- Method lookup path  (16-Jan)(17-Jan)
- Fake operators and equality  (16-Jan)  (17-Jan)

17-Jan

- Reading OO code (Debugging)  (17-Jan)
- Working with collaborator objects  (17-Jan)
- DOing a spike  (17-Jan)

- Instance variables, class variables, and constants, including the scope of each type and how inheritance can affect that scope  (16-Jan) (17-Jan)
- Modules  (16-Jan)(17-Jan)
- Method lookup path  (16-Jan)(17-Jan)
- Fake operators and equality  (16-Jan)  (17-Jan)

18-Jan

- Classes and objects (15-Jan)  (18-Jan)
- Use attr_* to create setter and getter methods (15-Jan)  (18-Jan)
- How to call setters and getters (15-Jan)  (18-Jan)
- Instance methods vs. class methods (15-Jan)  (18-Jan)
- Method Access Control (15-Jan)  (18-Jan)
- Referencing and setting instance variables vs. using getters and setters (15-Jan)  (18-Jan)
- Class inheritance, encapsulation, and polymorphism (15-Jan)  (18-Jan)
  Calling methods with self (15-Jan)  (18-Jan)
  More about self (15-Jan)  (18-Jan)
- self (15-Jan)  (18-Jan)

- Reading OO code (Debugging)  (17-Jan)
- Working with collaborator objects  (17-Jan)
- DOing a spike  (17-Jan)

19-Jan

- Classes and objects (15-Jan)  (18-Jan)
- Use attr_* to create setter and getter methods (15-Jan)  (18-Jan)
- How to call setters and getters (15-Jan)  (18-Jan)
- Instance methods vs. class methods (15-Jan)  (18-Jan)
- Method Access Control (15-Jan)  (18-Jan)
- Referencing and setting instance variables vs. using getters and setters (15-Jan)  (18-Jan)
- Class inheritance, encapsulation, and polymorphism (15-Jan)  (18-Jan)
  Calling methods with self (15-Jan)  (18-Jan)
  More about self (15-Jan)  (18-Jan)
- self (15-Jan)  (18-Jan)


- Instance variables, class variables, and constants, including the scope of each type and how inheritance can affect that scope  (16-Jan) (17-Jan)
- Modules  (16-Jan)(17-Jan)
- Method lookup path  (16-Jan)(17-Jan)
- Fake operators and equality  (16-Jan)  (17-Jan)

- Reading OO code (Debugging)  (17-Jan)
- Working with collaborator objects  (17-Jan)
- DOing a spike  (17-Jan)


## Precision of Language

Some questions require that you explain code or concepts with words. It's important to explain how code works using precise vocabulary and to pinpoint the causal mechanism at work. In other words, use the right words and don't be vague.

In programming, we must always concern ourselves with outputs, return value, and object mutations. 

When writing answers to test questions, make sure you're as precise as possible, and that you use the proper vocabulary. Doing this helps you debug and understand more complex code later in your journey. If your definitions are imprecise, you can't use them to decompose a complicated method or program.

## Assessment Format

This assessment has a different style than the RB109 written assessment,so you should expect several open-ended questions where you will need to explain certain OOP concepts using code examples.